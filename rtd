#!/bin/bash
#::				S I M P L E     S Y S T E M   S U P P O R T    T O O L
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#:: Author(s):   	SLS, KLS, NB.  Buffalo Center, IA & Avarua, Cook Islands
    RTD_Version=1.09-Beta
#::
#::
#::	Purpose: To simplify support tasks
#::		  - Display system information
#::		  - Update system software
#:: 		  - Bakup virtual machines
#::               - Cleanup/Report on PPA's (Ubuntu only)
#::               - Show systems physical location
#::		  - Check if a password you intend to use is for sale on the Darknet
#::
#::     Usage: run the script "bash /path/to/rtd" or if installed in the $PATH; by rtd simply type "rtd" in a terminal.
#::
#::     This script is shared in the hopes that
#::     someone will find it usefull.
#::
#::
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#
#	NOTE:	This terminal program is written to be readable and documented to a very high degree. The reason is that
#		these apps are seldom changed and when they are, it is usefull to be able to understand why and how
#		things were built. Obviously, this becomes a useful learning tool as well; for all people that want to
#		learn how to write admin scripts. It is a good and necessary practice to document extensively and follow
#		patterns when building your own apps and config scripts. Failing to do so will result in a costly mess
#		for any organization after some years and people turnover.
#
#		As a general rule, we prefer using functions extensively because this makes it easier to manage the script
#		and facilitates several users working on the same scripts over time.
#
#
#	RTD admin scrips are placed in /opt/rtd/scripts. Optionally scripts may use the common
#	functions in _rtd_functions and _rtd_recipies:
#
#	  _rtd_functions -- contain usefull admin functions for scripts, such as "how to install software" on different systems.
#	  _rtd_recipies  -- contain software installation and configuration "recipies".
#
#	Scripts may also be stand-alone if there is a reason for this. This script is written to function independently
#	so that it is easy to copy to many server systems, or just to use once on a remote system. This is accomplished by
#	including all functions and dependency checking in this script; as well as avoidnig relying on external files like
#	*.diff files. As a consequence of the portability benefit this script becomes rather large and time consuming to navigate.
#
#	Taxonomy of this script: we prioritize the use of functions over monolithic script writing, and proper indentation
#	to make the script more readable. Each function shall also be documented to the point of the obvious.
#	Suggested function structure per google guidelines:
#
#	function_descriptive_name () {
#		# Documentation and comments...
#		...code...
#	}
#
#	We also like to log all activity, and to echo status output to the screen in a frienly way. To accomplish this,
#	the table below may be used as appropriate:
#
#				OUTPUT REDIRECTION TABLE
#
#		  || visible in terminal ||   visible in file   || existing
#	  Syntax  ||  StdOut  |  StdErr  ||  StdOut  |  StdErr  ||   file
#	==========++==========+==========++==========+==========++===========
#	    >     ||    no    |   yes    ||   yes    |    no    || overwrite
#	    >>    ||    no    |   yes    ||   yes    |    no    ||  append
#	          ||          |          ||          |          ||
#	   2>     ||   yes    |    no    ||    no    |   yes    || overwrite
#	   2>>    ||   yes    |    no    ||    no    |   yes    ||  append
#	          ||          |          ||          |          ||
#	   &>     ||    no    |    no    ||   yes    |   yes    || overwrite
#	   &>>    ||    no    |    no    ||   yes    |   yes    ||  append
#	          ||          |          ||          |          ||
#	 | tee    ||   yes    |   yes    ||   yes    |    no    || overwrite
#	 | tee -a ||   yes    |   yes    ||   yes    |    no    ||  append
#	          ||          |          ||          |          ||
#	 n.e. (*) ||   yes    |   yes    ||    no    |   yes    || overwrite
#	 n.e. (*) ||   yes    |   yes    ||    no    |   yes    ||  append
#	          ||          |          ||          |          ||
#	|& tee    ||   yes    |   yes    ||   yes    |   yes    || overwrite
#	|& tee -a ||   yes    |   yes    ||   yes    |   yes    ||  append
#
#	Our scripts are also structured in to three major sections: "settings", "functions", and "execute".
#	Settings, contain configurable options for the script. Functions, contain all functions. Execute,
#	contains all the actual logic and control of the script.
#
#
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::


#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::



#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#::::::::::::::                                          ::::::::::::::::::::::
#::::::::::::::            Script Settings               ::::::::::::::::::::::
#::::::::::::::                                          ::::::::::::::::::::::
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#
# You may comment out or edit items as you deem necessary.
# Some formatting options for cli graphic display.
export BRANDING="RunTime Data : Simple Support Tool"
export BRANDING_ORG="RTD"
export DIALOG_CANCEL=1
export DIALOG_ESC=255
export HEIGHT=20
export WIDTH=90
export LIST_HEIGHT=12

# Set location to backup virtual machines to. This location must have addequate space
# to store several copies of the virtual machine disks. This may be a network share or
# an external storage or san mount point. If you do non need to backup VMs you can set
# this to blank or ignore it. If you do not have QEMU/KVM installed selecting this
# option to back up Virtual Machines in the menu will do nothing.
VM_BACKUP_TARGET="/mnt/vmdsk/VM_BACKUP"

# Terminal Color Setup definitions. These settings allow the simlified use of
# text colors in the teminal. You may want to echo RED for error or GREEN for OK.
YELLOW="\033[1;33m"
RED="\033[1;31m"
ENDCOLOR="\033[0m"
GREEN="\033[1;32m"
BLUE="\033[1;34m"

# Set the background color of the tool. The appearance of the manu system may
# look different on different systems depending on their default settings.
# Here we define the bacground color for consistency by seting the NEWT_COLORS= option. If "dialog"
# is the desired front end then you may set the DIALOG_COLORS= optoin for preferred colors.
# You may select a front end to the rtd tool below by seting the RTD_GUI= option.
# Valid choices are: "dialog", "whiptail".
RTD_GUI=whiptail
export NEWT_COLORS='root=,gray '
DIALOG_COLORS=WHITE,black,ON
xhost local:root

# Details for the ISO image creator. To change from one Ubuntu release to another you
# may change the "RELEASE" option. If you wold like to use the ISO maker to build a custom
# Debian installer you may change the "SOURCE_ISO_URL" option to poit to the Debian location.
# Finally, should you desire using your own preseed template (answers to the install questions)
# you should change the "PRESEED_TEMPLATE" option to point to the location of you own template.
TARGET_ISO_FILE_NAME=
SOURCE_ISO_URL=
SSH_PUBLIC_KEY_FILE=
PUT_ISO_FILE_HERE_WHEN_DONE=
PUT_QCOW_FILE_HERE_WHEN_DONE=
VOLUME_TITLE=
PRESEED_TEMPLATE=

# Set location to where to log information:
# in the system log directory in a file named the same as this script.
LOGFILE="/var/log/${0##*/}.log"
#DBG=#

# Base folder structure for optional administrative commandlets and scripts:
#_RTDSCR=$(if [ -f /opt/rtd/scripts ]; then echo /opt/rtd/scripts ; else ( mkdir -p /opt/rtd/scripts & echo  /opt/rtd/scripts ) ; fi )
#_RTDCACHE=$(if [ -f /opt/rtd/cache ]; then echo /opt/rtd/cache ; else ( mkdir -p /opt/rtd/cache & echo  /opt/rtd/cache ) ; fi )
_RTDLOGSD=$(if [ -f /var/log/rtd ]; then echo /var/log/rtd ; else ( mkdir -p /var/log/rtd & echo  /var/log/rtd ) ; fi )

# Determine log file directory
_ERRLOGFILE=$_RTDLOGSD/$( basename $0)-error.log
_LOGFILE=$_RTDLOGSD/$( basename $0).log
#_STATUSLOG=$_RTDLOGSD/$( basename $0)-status.log

#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#::::::::::::::                                          ::::::::::::::::::::::
#::::::::::::::            Tool Executive Functions      ::::::::::::::::::::::
#::::::::::::::                                          ::::::::::::::::::::::
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#
# Below please find the executive functions of this script. These are the functions
# that actually do the work requested.
#
#


rtd_oem_pause() {
	if [ ! $1 -eq 0 ]; then
		read -p "Press  [ ENTER ] to continue:"
	fi 
}

ensure_admin () {
	# Function to ensure administrative privileges such that system wide settings
	# or configuration may be done. This function will make the script call itself
	# with sudo if the user ID is not 0 e.g. root.

		[ "$UID" -eq 0 ] || echo -e $YELLOW "The $BLUE $BRANDING $YELLOW needs administrative access..." $ENDCOLOR
		[ "$UID" -eq 0 ] || exec sudo bash "$0" "$@"

}



check_if_password_p0wned () {
	pass_str=$($RTD_GUI --passwordbox "Please enter your intended password to validate your new password against P0wned DB" 8 78 --title "" 3>&1 1>&2 2>&3)
	result=$(
		sha1=$(echo -n $pass_str | tr -d '\n' | sha1sum); echo "Hash prefix: ${sha1:0:5}"; echo "Hash suffix: ${sha1:5:35}";
		query_result=$(curl https://api.pwnedpasswords.com/range/${sha1:0:5} 2>/dev/null | grep $(echo ${sha1:5:35} | tr '[:lower:]' '[:upper:]'));
		printf "Your password appeared %d times for sale in the Darknet per the P0wned online database...." "${query_result#*:}" 2>/dev/null ;
		unset pass_str ;
		)
	display_result "Password P0wned Status"
}



convert_vdi_2_qcow2 () {
	# Function to import a VirtualBox image to KVM. qcow is a file format for disk
	# image files used by QEMU, a hosted virtual machine monitor.[1] It stands for
	# "QEMU Copy On Write" and uses a disk storage optimization strategy that delays
	# allocation of storage until it is actually needed. This is the required format for
	# qemu/KVM virtual machines. VDI: This format is the VirtualBox-specific VirtualBox Disk Image
	qemu-img convert -f vdi -O qcow2 $VDI $QCOW2
}



change_disk_pass () {
	# Function to change the passphrase fo an encrypted storage device.
	# It will offer to change the first encrypted volume found by blockid.
	# It is unclear how this will work if there are multiple encrypted volumes found.
	clear
	echo Changing the disk encryption password for your hard drive:
	cryptsetup luksChangeKey $(blkid | grep crypto_LUKS|  cut -d : -f 1)
	read -p "Press  [ ENTER ] to continue:"

}



rtd_oem_setup_brand_splash_screen() {
	# Function to brand the installer splash screen for the customized installer
	# downloaded from a ginve vendor. This function expects a few simple peices of information:
	# parameter 1: full path to image file to be branded.
	# parameter 2: quoted text to be incerted.
	image_file_to_brand=$1
	text_to_brand_with=$2

	# Ensure that imagemagik is installed so images can be manipulated.
	check_dependencies imagemagick

	# Default locations and splash screens based on debian and ubuntu, meaning this function will assume you are
	# making an ubuntu or debian boot iso as this is generally what this function was written to do. However these values
	# can be overridden by passing the 2 parameters to this script.
	: "${image_file_to_brand:="$(
		if [ -f $TMP_DISC_DIR/splash.png ]; then
			echo "$TMP_DISC_DIR/splash.png"
		elif  [ -f $TMP_DISC_DIR/isolinux/splash.png ]; then
			echo "$TMP_DISC_DIR/isolinux/splash.png"
		elif [ -f $TMP_DISC_DIR/isolinux/splash.png ]; then
			echo "$TMP_DISC_DIR/isolinux/splash.png"
		fi )" }"

	: "${text_to_brand_with:="$( echo " RunTime Data OEM Install: $PREFERENCE" )" }"

	echo -e $GREEN "found: $image_file_to_brand"  $ENDCOLOR
	echo -e $GREEN "branding with: $text_to_brand_with " $ENDCOLOR

	if [ -f $image_file_to_brand ]; then
		convert $image_file_to_brand -gravity north -stroke '#000C' -strokewidth 3 -annotate 0 "$text_to_brand_with" -stroke none -strokewidth 3 -fill white -annotate 0 " $text_to_brand_with "  edit-out.png
		rm $image_file_to_brand
		mv edit-out.png $image_file_to_brand || echo -e $RED "Image [ $image_file_to_brand ] NOT branded!  " $ENDCOLOR

	fi
}





prepare_environment_for_iso_creation ()
{
	# Function to check that all dependencies are available for manipulating the
	# net install ISO from Ubuntu. Subsequently, the temporary file locations
	# are setup and templates are downloaded.

	#Include the path to where the isofile will be put...
	: "${TARGET_ISO="$PUT_ISO_FILE_HERE_WHEN_DONE/$TARGET_ISO_FILE_NAME"}"
	# Ensure that all needed software, outside of the most rudimantary,
	# is available to us... If not, the script should exit.
	: "${_DEPENDENCIES="dos2unix cpio gzip genisoimage whois pwgen wget fakeroot xorriso"}"
	#set -e
	for i in $_DEPENDENCIES
	do
		check_dependencies $i
	done

	# Find full paths for the binaries needed since if they are recently
	# added, they may not be found in the current $PATH. These statements will be evaluated
	# when the variables are referenced not here because of the ":". FYI...
	: "${BIN_7Z:=$(type -P 7z)}"
	: "${BIN_XORRISO:=$(type -P xorriso)}"
	: "${BIN_CPIO:=$(type -P gnucpio || type -P cpio)}"
	: "${BIN_QEMU_IMG:=$(type -P qemu-img)}"
	: "${BIN_KVM:=$(type -P kvm)}"
	: "${BIN_QEMU_SYSTEM_X86_64:=$(type -P qemu-system-x86_64 )}"
	: "${ISOHDPFX_BIN:=$(locate isohdpfx.bin  | head -n 1)}"
	: "${PUT_ISO_FILE_HERE_WHEN_DONE:="/home/$SUDO_USER/Virtual-DVDs"}"
	: "${PUT_QCOW_FILE_HERE_WHEN_DONE:="/home/$SUDO_USER/Virtual-HDs"}"
	: "${VOLUME_TITLE:="RTD Auto Installer"}"
	: "${SSH_PUBLIC_KEY_FILE:="/home/$SUDO_USER/.ssh/id_rsa.pub"}"
	: "${PERMANENT_DOWNLOAD_DIR:="/home/$SUDO_USER/Virtual-DVDs/Downloaded"}"

	# Find the location of the public key on this machine...
	# This should be updated to create a key if not there...
	if [ ! -f "$SSH_PUBLIC_KEY_FILE" ];
	then
		echo "Error: public SSH key $SSH_PUBLIC_KEY_FILE not found!"
		echo "You will need to setup automatic login using ssh manually each time you build a server with this media."
		read -p "Press [Enter] to continue..."
	fi

	# Setup the required folder structure...
	CURRENT_DIR="`pwd`"
	SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
	TMP_DOWNLOAD_DIR=$(mktemp -d )
	TMP_DISC_DIR=$(mktemp -d )
	TMP_INITRD_DIR=$(mktemp -d )

	for i in $PUT_QCOW_FILE_HERE_WHEN_DONE\
		$PUT_ISO_FILE_HERE_WHEN_DONE\
		$PERMANENT_DOWNLOAD_DIR
	do
		mkdir -p -m 770 "$i" && chown $SUDO_USER:$SUDO_USER "$i"
	done
}


rtd_oem_ubuntu_auto_install_iso_builder()
{
	# Function to generate an edited ISO file from a folder.
	# this function expects a minimum of one parameter: ssh-server, ubuntu-desktop, kubuntu-desktop, xubuntu-desktop, lubuntu-desktop etc.
	# By default the server ISO image will be downloaded and manipulated. Optionally this function can be told to use the
	# Ubuntu Desktop ISO instead of the server iso by passing a second parameter:
	# :: function name			:: target	   :: iso version to download
	# rtd_oem_ubuntu_auto_install_iso_builder ubuntu-desktop       desktop
	#
	CONFIG=$1
	ISO_VER=$2
	prepare_environment_for_iso_creation

	# Retreive list of available Ubuntu versions:
	all=($(wget -O- releases.ubuntu.com -q | perl -ne '/Ubuntu (\d+.\d+)/ && print "$1\n"' | sort -Vu))

	# Ask for desired version to use:
	UBUNTU_VER=$($RTD_GUI \
			--inputbox "Please pick an available ubuntu version by entering it below. Versions to choose from: ${all[*]} If you are not sure just let me choose for you... I will allways choose the latest available version. " \
			8 78 "${all[-1]}" \
			--title "Select Release Version of Ubuntu" \
			3>&1 1>&2 2>&3)
	[ "$UBUNTU_VER" ] || UBUNTU_VER=${all[-1]}

	# Find the precice location of the requested ISO image:
	ISO_URL=$(rtd_oem_find_live_release $UBUNTU_VER $ISO_VER)
		echo "requested iso for download : $ISO_URL"
		ISO_FILENAME=$(basename $ISO_URL)
		BASE=$(basename $ISO_URL .iso)

	echo "Checking if $ISO_FILENAME already downloaded..."
	iso=$(find "$PERMANENT_DOWNLOAD_DIR" -name "$ISO_FILENAME")
	if [ ! -e "$iso" ]; then
		echo "$ISO_FILENAME is not in cache, downloading..."
		wget -nc $ISO_URL -P "$PERMANENT_DOWNLOAD_DIR" || return 1
		iso="$PERMANENT_DOWNLOAD_DIR/$ISO_FILENAME"
	fi
	rtd_oem_pause $?

	mnt="${TMP_DISC_DIR:=$(mktemp -d )}"
	TMP_DISC_DIR=$mnt
	echo "Temorary Disk dir: $TMP_DISC_DIR"
	mount $iso $mnt -o user,ro || rtd_oem_pause 1
	    cat $mnt/.disk/*info
	    read a b c < $mnt/.disk/*info
	auto=$BRANDING_ORG-$CONFIG-auto-install-from-${BASE}
	echo -e "$YELLOW Creating Installations media: $auto $BLUE"
	if [ ! -e $auto ]; then
		cp -a $mnt $auto
		chmod -R +w $auto
	fi

	echo -e "$YELLOW Unmounting $mnt... $ENDCOLOR"
	sudo umount $mnt || rtd_oem_pause 1
	echo -e "$BLUE Modifying installation instructions...  $BLUE"

	case "$2" in
		desktop | Desktop)
			#configure_auto_unattended_ubuntu_live_boot_media $auto $CONFIG && echo -e "$GREEN OK! $ENDCOLOR" || rtd_oem_pause 1

			cat > $auto/isolinux/txt.cfg <<- EOF
				default live-install
				label live-install
				menu label ^^Auto Install Ubuntu $CONFIG
				kernel /casper/vmlinuz
				append  file=/cdrom/preseed.cfg auto=true priority=critical debian-installer/locale=en_US keyboard-configuration/layoutcode=us ubiquity/reboot=true languagechooser/language-name=English countrychooser/shortlist=US localechooser/supported-locales=en_US.UTF-8 boot=casper automatic-ubiquity initrd=/casper/initrd quiet splash noprompt noshell ---
			EOF

			make_preseed_cfg $auto $CONFIG

		;;
		*)
			#configure_auto_unattended_ubuntu_server_boot_media $auto $CONFIG && echo -e "$GREEN OK! $ENDCOLOR" || rtd_oem_pause 1
			cat > $auto/isolinux/isolinux.cfg <<- EOF
				default install
				label install
				gfxmode=791
				ui gfxboot bootlogo
				path
				timeout 100
				menu label ^Auto Install Ubuntu $CONFIG
				kernel /install/vmlinuz
				append file=/cdrom/preseed/ubuntu-server.seed initrd=/install/initrd.gz ks=cdrom:/ks.cfg preseed/file=/cdrom/preseed.cfg --
			EOF

			touch $auto/preseed.cfg
			cat > $auto/boot/grub/grub.cfg <<- 'EOF'
			set timeout=10
			GRUB_GFXMODE="1024x768"
			set menu_color_normal=white/black
			set menu_color_highlight=black/light-gray
			EOF

			make_preseed_cfg $auto $CONFIG

		;;
	esac

	echo -e "$YELLOW Modifying startup instructions...  $BLUE"

	cat >> $auto/ks.cfg <<-EOF
	%post --nochroot
	mkdir -p /target/root/.ssh/
	echo $(cat  $SSH_PUBLIC_KEY_FILE ) >> /target/root/.ssh/authorized_keys
	chown -R root /target/root/.ssh/
	%end
	EOF

	TARGET_ISO="$PUT_ISO_FILE_HERE_WHEN_DONE/$auto.iso"

	rtd_oem_setup_brand_splash_screen $mnt/isolinux/splash.png || rtd_oem_pause 1
	if [[ -f $TARGET_ISO ]]; then
		rm $TARGET_ISO
	fi

	$BIN_XORRISO -as mkisofs -isohybrid-mbr "$ISOHDPFX_BIN" \
		-c isolinux/boot.cat -b isolinux/isolinux.bin \
		-no-emul-boot -boot-load-size 4 -boot-info-table \
		-eltorito-alt-boot -e boot/grub/efi.img -no-emul-boot \
		-isohybrid-gpt-basdat -o "$PUT_ISO_FILE_HERE_WHEN_DONE/$auto.iso" $auto
	rtd_oem_pause $?
	umount -l $mnt
	rm -rf $mnt $auto

	if ($RTD_GUI --title "Created $auto.iso" --yesno "Would you like to test the new image?." 8 78); then
    		echo "User selected Yes, exit status was $?."
		check_dependencies qemu-kvm
		qemu-img create -f qcow2 "$PUT_QCOW_FILE_HERE_WHEN_DONE/$auto.qcow2" 10G
		qemu-system-x86_64 -smp 2 -enable-kvm -m 4G --cdrom "$TARGET_ISO" "$PUT_QCOW_FILE_HERE_WHEN_DONE/$auto.qcow2"
	else
    		echo "User selected No, exit status was $?."
	fi
}




download_and_manipulate_iso_debian () {
	# ownload_and_manipulate_iso_debian "debian" "openssh-server" "MinecraftTasks"
	# This is a simple command sequence to read the preference of distribution to install
	# and what release to get... then download the network install file from ubuntu
	# and manipulate the iso file to complete the edited instruction in the preseed.cfg...
	: "${PRESEED_TEMPLATE:="https://github.com/vonschutter/Blind_Install/raw/master/custom/preseed.debian.template"}"
	: "${TARGET_ISO_FILE_NAME:="$1-$2-mini-netinstall-auto.iso"}"
	: "${SOURCE_ISO_URL:="https://cdimage.debian.org/debian-cd/current/amd64/iso-cd/$(curl --silent  https://cdimage.debian.org/debian-cd/current/amd64/iso-cd/MD5SUMS | \grep -o "debian-.*netinst*.iso" |grep -v mac |grep -v edu)"}"
	: "${SOURCE_FIRMWARE:="http://cdimage.debian.org/cdimage/unofficial/non-free/firmware/buster/current/firmware.zip"}"
	TARGET_ISO="$PUT_ISO_FILE_HERE_WHEN_DONE/$TARGET_ISO_FILE_NAME"
	PREFERENCE=$2

	echo -e $YELLOW Geting install image...
	echo -e $GREEN Download: $SOURCE_ISO_URL $ENDCOLOR
	# Download the current version of Debian stable and extract its contents
	# to a known location.
	cd "$TMP_DOWNLOAD_DIR"
	wget -4  -q --show-progress "$SOURCE_ISO_URL" -O "./netboot.iso"
	"$BIN_7Z" x "./netboot.iso" "-o$TMP_DISC_DIR"
	echo -e $BLUE; ls $TMP_DISC_DIR ; echo -e $ENDCOLOR
	rtd_oem_pause $?
	echo -e $YELLOW Geting non-free firmware...
	echo -e $GREEN Download: $SOURCE_FIRMWARE $ENDCOLOR
	# By default Debian does not include non-free firmware to be able to use
	# some wireless cards; so these will need to be downloaded.
	wget -4  -q --show-progress "$SOURCE_FIRMWARE" -O "$TMP_DOWNLOAD_DIR/firmware.zip"
	mkdir $TMP_DISC_DIR/firmware
	"$BIN_7Z" x "$TMP_DOWNLOAD_DIR/firmware.zip" "-o$TMP_DISC_DIR/firmware"
	echo -e $BLUE ; ls $TMP_DISC_DIR/firmware ; echo -e $ENDCOLOR

	cd "$TMP_DISC_DIR" || echo -e $RED "Temorary directory $TMP_DISC_DIR does not exist!" $ENDCOLOR

	# Load the installation answers template.
	echo -e $YELLOW Getting intall instructions template... $ENDCOLOR
	mkdir -p $SCRIPT_DIR/custom
	make_preseed_cfg "$SCRIPT_DIR/custom/preseed.template" "$PREFERENCE" 

# ------------------- Patch 1 grub .cfg ------------------------ #

patch ./boot/grub/grub.cfg <<PATCH
11a12
> set timeout=10
13c14
< menuentry "Install" {
---
> menuentry "Automatic Install" {
PATCH

# -------------------------------------------------------------- #


# ---------------------Patch 2 isolinux.cfg -------------------- #

dos2unix "./isolinux/isolinux.cfg"
patch ./isolinux/isolinux.cfg <<PATCH_II
7c7
< timeout 0
---
> timeout 100
PATCH_II

# -------------------------------------------------------------- #

	# Edit the installation instructions file...
	cat "$SCRIPT_DIR/custom/preseed.template" > "$SCRIPT_DIR/custom/preseed.cfg"
	sed -i s/oem-replace-me-desktop-selection/$PREFERENCE/g "$SCRIPT_DIR/custom/preseed.cfg"
	cd "$TMP_INITRD_DIR"
	mkdir ./custom
	cp "$SCRIPT_DIR/custom/preseed.cfg" "./preseed.cfg"
	cp "$SSH_PUBLIC_KEY_FILE" "./custom/userkey.pub"

# ---------------------Create ssh key service ------------------ #

cat << SSH_KEY_KEYGEN > ./custom/ssh-host-keygen.service
[Unit]
Description=OpenSSH Server Key Generation
Before=ssh.service

[Service]
ExecStart=/usr/bin/ssh-keygen -A
Type=oneshot
RemainAfterExit=yes

[Install]
WantedBy=multi-user.target
SSH_KEY_KEYGEN

# -------------------------------------------------------------- #

	# Inject created content into the new ISO...
	echo -e $GREEN "# Modify the CLI Installer" $ENDCOLOR
	cat "$TMP_DISC_DIR/install.amd/initrd.gz" | gzip -d > "./initrd"
	echo "./preseed.cfg" | fakeroot "$BIN_CPIO" -o -H newc -A -F "./initrd"
	find "./custom" | fakeroot "$BIN_CPIO" -o -H newc -A -F "./initrd"
	cat "./initrd" | gzip -9c > "$TMP_DISC_DIR/install.amd/initrd.gz"
	rm ./initrd

	echo -e $GREEN "# Modify the GTK Installer" $ENDCOLOR
	cat "$TMP_DISC_DIR/install.amd/gtk/initrd.gz" | gzip -d > "./initrd"
	echo "./preseed.cfg" | fakeroot "$BIN_CPIO" -o -H newc -A -F "./initrd"
	find "./custom" | fakeroot "$BIN_CPIO" -o -H newc -A -F "./initrd"
	cat "./initrd" | gzip -9c > "$TMP_DISC_DIR/install.amd/gtk/initrd.gz"

	rtd_oem_setup_brand_splash_screen


}



create_iso_image ()
{
	# Function to generate the new ISO file from the extracted and
	# altered original ISO.
	# Delete old iso file if there...
	echo "------ CREATING ISO: $TARGET_ISO    --------"
	if [ -f "$TARGET_ISO" ]; then
		rm -f "$TARGET_ISO"
	fi

	cd "$TMP_DISC_DIR"
	rm -r '[BOOT]'
	"$BIN_XORRISO" -as mkisofs -r -V "$VOLUME_TITLE" -J -b isolinux.bin -c boot.cat -no-emul-boot -boot-load-size 4 -boot-info-table -input-charset utf-8 -isohybrid-mbr "$ISOHDPFX_BIN" -eltorito-alt-boot -e boot/grub/efi.img -no-emul-boot -isohybrid-gpt-basdat -o "$TARGET_ISO" ./
	chmod 777 "$TARGET_ISO" || read -p "An error may have occurred (review above outout) then: Press [ENTER] to continue:"
}



create_iso_image_debian ()
{
	# Function to generate the new ISO file from the extracted and
	# altered original ISO.
	# Delete old iso file if there...
	echo "------ CREATING ISO: $TARGET_ISO    --------"
	if [ -f "$TARGET_ISO" ]; then
		rm -f "$TARGET_ISO"
	fi

	cd "$TMP_DISC_DIR"
	rm -r '[BOOT]'
	"$BIN_XORRISO" -as mkisofs -r -V "$VOLUME_TITLE" -J -b "isolinux/isolinux.bin" -c boot.cat -no-emul-boot -boot-load-size 4 -boot-info-table -input-charset utf-8 -isohybrid-mbr "$ISOHDPFX_BIN" -eltorito-alt-boot -e boot/grub/efi.img -no-emul-boot -isohybrid-gpt-basdat -o "$TARGET_ISO" ./
	chmod 777 "$TARGET_ISO" || read -p "An error may have occurred (review above outout) then: Press [ENTER] to continue:"

	# Test the created ISO file by booting it in a temporary VM using qemu.
	if ($RTD_GUI --title "Created $(basename $TARGET_ISO .iso)" --yesno "Would you like to create a Virtual Hardisk as well for later use?." 8 78); then
    		echo "User selected Yes, exit status was $?."
		check_dependencies qemu-kvm
		"$BIN_QEMU_IMG" create -f qcow2 "$PUT_QCOW_FILE_HERE_WHEN_DONE/$(basename $TARGET_ISO .iso).qcow2" 10G
		qemu-system-x86_64 -smp 2 -enable-kvm -m 4G --cdrom "$PUT_ISO_FILE_HERE_WHEN_DONE/$(basename $TARGET_ISO .iso).iso" "$PUT_QCOW_FILE_HERE_WHEN_DONE/$(basename $TARGET_ISO .iso).qcow2"
	else
    		echo "User selected No, exit status was $?."
	fi
}




make_kvm_virtual_machine_now_from_debian_org () {
	# Function to create a KVM virtual michine disk and define a VM. This function should be
	# used on a Qemu/KVM virtual host that the virtual guest is to be used on.
	# NOTE: QCOW2 is a storage format for virtual .
	# machine disk images QCOW stands for QEMU copy on write. The QCOW2 format decouples the physical storage
	# layer from the virtual layer by adding a mapping between logical and physical blocks.
	# NOTE2: Kernel-based Virtual Machine (KVM) is an open source virtualization technology built into Linux®.
	# Specifically, KVM lets you turn Linux into a hypervisor that allows a host machine to run multiple,
	# isolated virtual environments called guests or virtual machines (VMs). KVM is part of Linux.
	# For complete info: https://www.redhat.com/en/topics/virtualization/what-is-KVM
	# set -e
	# Use the check_dependencies function to make sure the needed software is available.
	# Usage: Either simply call this function to use the defaults or:
	# Call this function with "function" "RAM_SIZE" "DISK_SIZE" "DISK_FORMAT" "DISK_FILE"
	# Omitting any of the arguments will us the default instead.

	for i in qemu-utils qemu-kvm qemu-system-x86
	do
		check_dependencies $i || $RTD_GUI --backtitle "$BRANDING" --title "NOTICE!" --msgbox "$i is missing from this computer; and I could not install it either..." 10 60
	done

	# Lookup specific binaries: use full path since they may just have been added and not in $PATH yet.
	: "${BIN_VIRT_INSTALL:=$(type -p virt-install)}"

	# create image and run installer
	"${BIN_VIRT_INSTALL}" --name VDI_Debian_"$CONFIG"_"$RANDOM" \
		--vcpus "${2:-2}" \
		--memory "${3:-2048}" \
		--network default \
		--location=http://ftp.us.debian.org/debian/dists/buster/main/installer-amd64/  \
		--disk size="${4:-20}" \
		--os-variant="${1:-debian10}" \
		--initrd-inject="$PRESEED_FILE" \
		--extra-args "ks=file:/$(basename $PRESEED_FILE)" --noautoconsole || "$RTD_GUI" --backtitle "$BRANDING" --title "NOTICE!" --msgbox "ERROR: -- Building VM using $PRESEED_FILE and internal instruction: ks=file:/$(basename $PRESEED_FILE)" 10 60
	$RTD_GUI --backtitle "$BRANDING" --title "NOTICE!" --msgbox "The virtual machine is currently being built. You may attach to this server and see the progress at IP: $(hostname -I))" 10 60

}






make_kvm_virtual_machine_now_from_iso () {
	# Function to create a KVM virtual michine disk and define a VM. This function should be
	# used on a Qemu/KVM virtual host that the virtual guest is to be used on.
	# NOTE: QCOW2 is a storage format for virtual .
	# machine disk images QCOW stands for QEMU copy on write. The QCOW2 format decouples the physical storage
	# layer from the virtual layer by adding a mapping between logical and physical blocks.
	# NOTE2: Kernel-based Virtual Machine (KVM) is an open source virtualization technology built into Linux®.
	# Specifically, KVM lets you turn Linux into a hypervisor that allows a host machine to run multiple,
	# isolated virtual environments called guests or virtual machines (VMs). KVM is part of Linux.
	# For complete info: https://www.redhat.com/en/topics/virtualization/what-is-KVM
	# set -e
	# Use the check_dependencies function to make sure the needed software is available.
	# Usage: Either simply call this function to use the defaults or:
	# Call this function with "function" "RAM_SIZE" "DISK_SIZE" "DISK_FORMAT" "DISK_FILE"
	# Omitting any of the arguments will us the default instead.

	for i in qemu-utils qemu-kvm qemu-system-x86
	do
		check_dependencies $i || $RTD_GUI --backtitle "$BRANDING" --title "NOTICE!" --msgbox "$i is missing from this computer; and I could not install it either..." 10 60
	done

	# Lookup specific binaries: use full path since they may just have been added and not in $PATH yet.
	: "${BIN_QEMU_IMG:=$(type -P qemu-img)}"
	: "${BIN_KVM:=$(type -P kvm)}"
	: "${BIN_QEMU_SYSTEM_X86_64:=$(type -P qemu-system-x86_64 )}"
	: "${BIN_VIRT_INSTALL:=$(type -p virt-install)}"

	#Verify ISO presesnce
		if [[ ! -f "$TARGET_ISO" ]]; then
			$RTD_GUI --backtitle "$BRANDING" --title "NOTICE!" --msgbox "OOOPS! I cannot find the ISO image to build the VM... " 10 60
			show_main_menu
		fi

	# create image and run installer
	virt-install --name VM_Template_"$1"_"$RANDOM" --vcpus "${"2"}" --memory "${"2048"}" --network default --cdrom="$TARGET_ISO" --disk size="${"20"}" --os-variant="${1:-"debian10"}"
	$RTD_GUI --backtitle "$BRANDING" --title "NOTICE!" --msgbox "The virtual machine is currently being built. You may attach to this server and see the progress at IP: $(hostname -I)" 10 60
}



set_install_command () {
	# add global install command for portability and convenience
	# If you need to use this script in an rpm based system you could modify the install
	# command here to suit dnf, yum, zypper... By default packages of patternd that do not
	# match should be skipped. Use "export option" so child processes also see the variiables.
	if [[ 'echo $OSTYPE" |grep "linux"' ]]; then
		if hash pkcon 2>/dev/null; then
			# If package kit is available then prefer this
			echo -e $YELLOW "Setting install options for Package Kit" $ENDCOLOR
			export _INSTCMD="pkcon -y  install"
		elif hash yum 2>/dev/null; then
			# If package kit is not available try yum (RedHat, Cent OS, Fedora)
			echo -e $YELLOW "Setting install options for YUM" $ENDCOLOR
			export _INSTCMD="yum -y  install"
		elif hash apt 2>/dev/null; then
			# If package kit is not available try apt (Debian, Ubuntu, and all derivatives)
			echo -e $YELLOW "Setting install options for DEB" $ENDCOLOR
			export _INSTCMD="apt-get -y -qq --allow-change-held-packages --ignore-missing install"
			export DEBIAN_FRONTEND=noninteractive
		elif hash zypper 2>/dev/null; then
			# If package kit is not available try zypper (Open SUSE)
			echo -e $YELLOW "Setting install options for ZYPPER" $ENDCOLOR
			export _INSTCMD="zypper install -y "
		else
			echo -e $YELLOW "This system does not seem to have a software managment system" $ENDCOLOR
			exit 1
		fi

	elif [[ "$OSTYPE" == "freebsd"* ]]; then
		echo "Free BSD is currently unsupported... "
		export _INSTCMD="echo I dont know how to install suff on FreeBSD!"
	else
	echo "I have no Idea what this system is"
		export _INSTCMD="Whatever!"
		exit 1
	fi
}



is_software_package_installed () {
	# Function to check if a piece of software is installed. This function will first check
	# if the package manager is deb, zypper or rpm, and then take one parameter passed
	# and evauate if a software package by that name is installed. This function
	# will return a "0" or "1" return based on the package managers return code.
	# Call this function by:
	# is_software_package_installed "package name"
	#                 or
	# is_software_package_installed "$1" if calling this function from a script
	# or another function receiving a parameter.
	#
	if hash yum 2>/dev/null; then
		rpm -q "$1" > /dev/null 2>&1 && return 0 || return 1
	elif hash apt 2>/dev/null; then
		dpkg -l "$1" 2>/dev/null |tail -1 |grep "ii  $1" > /dev/null 2>&1 && return 0 || return 1
	elif hash zypper 2>/dev/null; then
		zypper se "$1" > /dev/null 2>&1 && return 0 || return 1
	else
		return 3
	fi
}



is_software_package_available () {
	# Function to chek if a package is available in whetever repository, and
	# if there return a "0" and if not return a "1" or a "3" if there is no recognizable
	# package manager found. The function expects the name of the package
	# to be a parameter passed to this fuction. Call this function by:
	# is_software_package_available "package name"
	#                 or
	# is_software_package_available "$1" if calling this function from a script
	# or another function receiving a parameter.
	#
	# Supported base distributions: Fedora . SuSE . Debian
	if hash yum 2>/dev/null; then
		yum list available "$1" &> /dev/null && return 0 || return 1
	elif hash apt 2>/dev/null; then
		apt -qq list "$1" 2>/dev/null | grep -q "$1" && return 0 || return 1
	elif hash zypper 2>/dev/null; then
		return zypper info "$1" &> /dev/null && return 0 || return 1
	else
		return 3
	fi
}



InstallSoftwareFromRepo () {
	# Function to simplify the installation of software by including all display and
	# installation logic for a given software provider. This should be expanded to include flatpack
	# snap for example. It should be the same consistent way no matter flavor of Linux.
	# This function uses the "$_INSTCMD" to install software. "$_INSTCMD" is defined separatley and could
	# be an RPM or deb string, or even snap or flatpack. A preference order between package system and
	# snap or flatpack use.

	# make some decent display terminal Graphics...
	# This function uses set_install_command and ensure_admin to be able to, and know how to, install a package...
	#
	set_install_command
	ensure_admin
	PAD="--------------------------------------------------"
	LINE=$(printf "%s %s" "$@" "$PAD" | cut -c 1-${#PAD})
	# Test if package name is installed, if not then...
	if ! is_software_package_installed "$@"; then
		if is_software_package_available   "$@"; then
		echo -ne "--- Installing "$LINE" ":" "\ & $_INSTCMD "$@" >>$LOGFILE.log 2>&1 && printf "%b%-6s%b [ \xE2\x9C\x94 ] $GREEN OK!$ENDCOLOR   \n" ||printf "%b%-6s%b [ ! ] $RED FAILED $ENDCOLOR  \n"
		else
		echo -ne "--- Installing "$LINE" ":" "\ && printf "%b%-6s%b [ \xE2\x9C\x94 ] $YELLOW Not available $ENDCOLOR \n"
		fi
	else
		echo -ne "--- Installing "$LINE" ":" "\ && printf "%b%-6s%b [ \xE2\x9C\x94 ] $YELLOW Already installed $ENDCOLOR \n"
	fi

}



check_dependencies () {
    # Function to check that a piece of software is installed and if not install it.
    # Works for apt, yum, and rpm based systems currently as long as the package name is the same.
    # The function will take a parameter that is expected to match the software command line name
    # or rather the name of the package. This function now relies on the return value of
    # the function "is_software_package_installed" as it is a more reliable way to see if a package of
    # software is installed according to the package manamgent system rather than the "hash" function
    # that checks if a command is available, since command name and package name are not allways the same...

	#---------------------------------------------------------------
        echo "Validating dependencies and installing them if not there..."
	#---------------------------------------------------------------
        if is_software_package_installed $1 ; then
		echo -e "$YELLOW $1 $ENDCOLOR is present on this system..."
        else
                echo -e "$YELLOW $1 $ENDCOLOR not found: I will try to get it... "
                InstallSoftwareFromRepo $1
                if [ $? != 0 ];
                then
                        echo -e $RED "That install didn't work out so well!"
                        echo -e "Please manually try to add the software since I couldn't do it." $ENDCOLOR
                        exit 1
                fi
        echo "OK Done! Continuing..."
        fi
}




rtd_update_system () {
	PUBLICATION="$BRANDING Update Manager for Linux"
	VERSION="1.13 (built in)"
	# System update function. The purpose of this function is to update installed software from
	# distribution reopositories and the newer self contained universal software stores like
	# snap and flatpak.
	LOGFILE="${LOGFILE:=$0}"


	echo -e $GREEN"$PUBLICATION: Version $VERSION" $ENDCOLOR
	echo -e $GREEN"------------------------------------------------" $ENDCOLOR

	echo I am updating software from all channels i can find on the system.
	echo I will update via the native package manager as well as newer formats
	echo -e "like $YELLOW"snap"$ENDCOLOR and $YELLOW"flatpak"$ENDCOLOR..."
	echo " "


	log_item ()
	{
		DATE=$(date '+%d/%m/%Y %H:%M:%S');
		echo "$DATE --- : $@" >> $LOGFILE
	}


        rtd_software_task ()
        {
		log_item "running rtd_software_task with parameters $@"
		# make some decent display terminal graphics...
		PAD="------------------------------------------"
		LINE=$(printf "%s %s" "$@" "$PAD" | cut -c 1-${#PAD})
		echo -ne "--- Executing "$LINE"":""\ & $@ >>$LOGFILE 2>&1 && printf "%b%-6s%b [ \xE2\x9C\x94 ] $GREEN OK!$ENDCOLOR   \n" ||printf "%b%-6s%b [ ! ] $RED FAILED $ENDCOLOR  \n"
        }
        # Update native software packages; since it is not known what distribution
	# this script is being executed on, it is best to check and see if we are able
	# to perform an update and then do the update...
	# One could choose to check for a supported exact version: e.g. Ubuntu, but we would
	# like to be nice and add value for as many as we can. Specially if it is this easy! :)
	if hash pkcon 2>/dev/null; then
		# If package kit is available then prefer this
		echo -e $YELLOW "Using: Package Kit" $ENDCOLOR
		pkcon -y refresh 2>> $LOGFILE
		pkcon -y update --autoremove 2>> $LOGFILE
		#| $RTD_GUI --gauge "Updating native packages..." 6 50 0
	elif hash yum 2>/dev/null; then
		# If package kit is not available try yum (RedHat, Cent OS, Fedora)
		echo -e $YELLOW "Using: YUM" $ENDCOLOR
		rtd_software_task yum -y upgrade 2>> $LOGFILE
	elif hash apt 2>/dev/null; then
		# If package kit is not available try apt (Debian, Ubuntu, and all derivatives)
		echo -e $YELLOW "Using: DEB" $ENDCOLOR
		rtd_software_task apt-get update
		rtd_software_task apt-get upgrade -y
		rtd_software_task apt-get autoremove -y
	elif hash zypper 2>/dev/null; then
		# If package kit is not available try zypper (Open SUSE)
		echo -e $YELLOW "Using: ZYPPER" $ENDCOLOR
		rtd_software_task zypper up -y 2>> $LOGFILE
	else
		echo -e $YELLOW "This system does not seem to have a software managment system" $ENDCOLOR
		exit 1
	fi

        # updating snaps if snap is present on the system...
        if hash snap 2>/dev/null; then
                snap refresh 2>> $LOGFILE
		#| $RTD_GUI --gauge "Updating snap packages..." 6 50 0
        else
                echo "--- snap software is not present on this system... skipping..."
        fi

        # updating flatpacks if flatpack is present on system...
        if hash flatpak 2>/dev/null; then
                flatpak update -y 2>> $LOGFILE
		#| $RTD_GUI --gauge "Updating flapak packages..." 6 50 0
        else
                echo "--- flatpak software is not present on this system... skipping..."
        fi
}



backup_running_vm ()
{
	# Function to back up all funning virtual machines on the host it is being run on.
	# This function should be called from within this script and down not require any
	# parameters passed.


	do_vm_backup () {
		echo "Atempting backup of the folloing VM's:"
		virsh list
		# To exclude a VM (domain), add "nobackup" to its name and it will be ignored.
		# To rename: shutdown the guest, then use this command: virsh domrename "oldname" "newname".

		DATE=`date +%Y-%m-%d.%H:%M:%S`
		LOG=="/var/log/kvm-backup.$DATE.LOG"
		BACKUPROOT=${VM_BACKUP_TARGET:=/mnt/vmdsk/VM_BACKUP}

		#Get list of all running virtual machines
		DOMAINS=$(virsh list --all | tail -n +3 | awk '{print $2}')

		for DOMAIN in $DOMAINS; do
			echo "-----------WORKER START $DOMAIN-----------" > $LOG
			echo "Starting backup for $DOMAIN on $(date +'%d-%m-%Y %H:%M:%S')"  >> $LOG

			if [[ $DOMAIN == *"nobackup"* ]];then
				echo "Skipping $DOMAIN , because its excluded." > $LOG
				exit 1
			fi

			VMSTATE=`virsh list --all | grep $DOMAIN | awk '{print $3}'`
			if [[ $VMSTATE != "running" ]]; then
				echo "Skipping $DOMAIN , because its not running." > $LOG
				exit 1
			fi

			BACKUPFOLDER=$BACKUPROOT/KVM-BACKUPS/$DOMAIN
			if ! -d $BACKUPFOLDER ; then
				$RTD_GUI
			fi
			mkdir -p $BACKUPFOLDER
			TARGETS=$(virsh domblklist $DOMAIN --details | grep disk | awk '{print $3}')
			IMAGES=$(virsh domblklist $DOMAIN --details | grep disk | awk '{print $4}')
			DISKSPEC=""
			for TARGET in $TARGETS; do
				DISKSPEC="$DISKSPEC --diskspec $TARGET,snapshot=external"
			done

			virsh snapshot-create-as --domain $DOMAIN --name "backup-$DOMAIN" --no-metadata --atomic --disk-only $DISKSPEC >> $LOG
			if [ $? -ne 0 ]; then
				echo "Failed to create snapshot for $DOMAIN" > $LOG
				exit 1
			fi

			for IMAGE in $IMAGES; do
				NAME=$(basename $IMAGE)
				if test -f "$BACKUPFOLDER/$NAME"; then
				echo "Backup exists, merging only changes to image" > $LOG
				rsync -apvz --inplace $IMAGE $BACKUPFOLDER/$NAME >> $LOG
				else
				echo "Backup does not exist, creating a full sparse copy" > $LOG
				rsync -apvz --sparse $IMAGE $BACKUPFOLDER/$NAME >> $LOG
				fi
			done

			BACKUPIMAGES=$(virsh domblklist $DOMAIN --details | grep disk | awk '{print $4}')
			for TARGET in $TARGETS; do
				virsh blockcommit $DOMAIN $TARGET --active --pivot >> $LOG
				if [ $? -ne 0 ]; then
					echo "Could not merge changes for disk of $TARGET of $DOMAIN. VM may be in invalid state." > $LOG
					exit 1
				fi
			done

			for BACKUP in $BACKUPIMAGES; do
				if [[ $BACKUP == *"backup-"* ]];then

				echo "deleted temporary image $BACKUP" > $LOG
				rm -f $BACKUP
				fi
			done

			virsh dumpxml $DOMAIN > $BACKUPFOLDER/$DOMAIN.xml
			echo "-----------WORKER END $DOMAIN-----------" >> $LOG
			echo "Finished backup of $DOMAIN at $(date +'%d-%m-%Y %H:%M:%S')" >> $LOG
		done
	}

	if hash virsh ; then
		if ($RTD_GUI --title "Virtual Machine Backup" --yesno "Do you want me to back up these VM's?:
		$(virsh list --all)" 0 $WIDTH ); then
			do_vm_backup
		else
			show_manage_vm_gui
		fi
	else
		if ( $RTD_GUI --title "NOTICE!" --yesno "KVM Virtualization is not installed on this machine. May I attempt to install it for you on this machine?" $HEIGHT $WIDTH ) ; then
			check_dependencies qemu-kvm || ( whiptail --title "ERROR!" --msgbox "KVM install failed!" $HEIGHT $WIDTH & show_manage_vm_gui)  && whiptail --title "Notice!" --msgbox "KVM installation completed!"
			check_dependencies virt-goodies || ( whiptail --title "ERROR!" --msgbox "Virt Goodies install failed!" $HEIGHT $WIDTH & show_manage_vm_gui)  && whiptail --title "Notice!" --msgbox "Virt Goodies installation completed!"
			do_vm_backup
		else
			show_manage_vm_gui
		fi
	fi
}



rtd_ppa_checker ()
{
  for f in /etc/apt/sources.list.d/*.list; do
    grep -Po "(?<=^deb\s).*?(?=#|$)" "$f" | while read -r ENTRY ; do
    echo "ENTRY: $ENTRY"
        HOST=$(cut -d/ -f3 <<< "$ENTRY")

        if [ "ppa.launchpad.net" = "$HOST" ]; then
		USER=$(cut -d/ -f4 <<< "$ENTRY")
		PPA=$(cut -d/ -f5 <<< "$ENTRY")
		packageCount=$(awk '$1=="Package:" {if (a[$2]++ == 0) {system("dpkg -l "$2)}}' /var/lib/apt/lists/*"$USER"*"$PPA"*Packages 2>/dev/null | awk '/^ii/' | wc -l)
		echo "PPA: ppa:$USER/$PPA"
		echo "FILENAME: $f"
		echo "$packageCount package(s) installed"
		if [ "$packageCount" -eq 0 ] && [ "$1" == "--delete" ]; then
			sudo rm "$f" && echo "$f deleted"
		fi
		echo
        else
		USER=$(cut -d/ -f3 <<< "$ENTRY")
		PPA=$(cut -d/ -f4 <<< "$ENTRY")
		packageCount=$(awk '$1=="Package:" {if (a[$2]++ == 0) {system("dpkg -l "$2)}}' /var/lib/apt/lists/*"$USER"*Packages 2>/dev/null | awk '/^ii/' | wc -l)
		echo "REPOSITORY: $USER/$PPA"
		echo "FILENAME: $f"
		echo "$packageCount package(s) installed"
		if [ "$packageCount" -eq 0 ] && [ "$1" == "--delete" ]; then
			sudo rm "$f" && echo "$f deleted"
		fi
		echo
        fi
    done
done
}




dl ()
{
	# Function to ease and make consistent the downloading of the non repository packages and
	# install them. It can install any package that Package Kit can manage (available on most Linux dists)
	# It expects one parameter: the complete URL to download from.

	download_url="$1"
	fetch_file () { wget -P /opt/rtd/cache $download_url 1>>$_LOGFILE 2>>$_ERRLOGFILE ; }

	echo  "    - getting package $download_url ..."
	if hash wget >/dev/null ; then
		fetch_file
	else
		check_dependencies wget
		fetch_file
	fi

	echo "    - Installing package $download_file ..."
	if hash pkcon >/dev/null ; then
		pkcon install-local -y /opt/rtd/cache/$(basename $download_url) 1>>$_LOGFILE 2>>$_ERRLOGFILE
	else
		check_dependencies packagekit-tools
		pkcon install-local -y /opt/rtd/cache/$(basename $download_url) 1>>$_LOGFILE 2>>$_ERRLOGFILE
	fi
}






rtd_oem_find_live_release()
{
	# This function will return the URL for the version of Debian, Ubuntu server or Destktop requested.
	# 3 parameters are required for this function to know what to do: distro_version/
	# It will also try to read the available iso images and grab the latest or requested iso.
	# Example:
	# Function name 		: distro_version : distro_flavor : live_or_not : desktop_env
	# rtd_oem_find_live_release 	      10              debian         live           kde
	# rtd_oem_find_live_release 	      10              debian         live           cinnamon
	# rtd_oem_find_live_release 	      10              debian         net            ssh-server
	# rtd_oem_find_live_release 	      19.04.2         ubuntu         live
	distro_version=$(1:=10)
	distro_flavor=$(2:=debian)
	live_or_not=$(3:=live)
	desktop_env=$(4:=standard)

	case "$distro_flavor" in
	Ubuntu | ubuntu )
		case "$live_or_not" in
		Live | live | current-live )
			rel=http://releases.ubuntu.com/"$distro_version"
			echo "$rel/$(curl --silent $rel/MD5SUMS | \grep -o 'ubuntu-.*-desktop-amd64.iso')"
		;;
		server | netinst | net | mini )
			# 18.04 and later need to use the alternative installer
			# since the switch to subiquity
			if [ ${1:0:2} -ge 18 ]; then
				rel=http://cdimage.ubuntu.com/releases/"$distro_version"/release
				echo "$rel/$(curl --silent $rel/MD5SUMS | \grep -o 'ubuntu-.*-server-amd64.iso')"
			else
				rel=http://releases.ubuntu.com/$1
				echo "$rel/$(curl --silent $rel/MD5SUMS | \grep -o 'ubuntu-.*-server-amd64.iso')"
			fi
		;;
		* )
			$RTD_GUI --backtitle "$BRANDING" --title "ERROR!" --msgbox "You passed the function ${FUNCNAME[0]} the parameters $@. The 4th parameter should be either of: Live | live | current-live | server | netinst | net | mini! Not $live_or_not" 10 60
		;;
		esac
	;;
	Debian | debian)
		case "$live_or_not" in
		Live | live | current-live )
			# Debian renames the current iso images for each release. To get around this when downloading
			# the vesion number must be ignored and the desired flavor of the iso should be grabed.
			case "$desktop_env" in
			kde | gnome | xfce | cinnamon | lxde | lxqt | mate | standard )
				rel=https://cdimage.debian.org/debian-cd/current-live/amd64/iso-hybrid/
				echo "$rel/$(curl --silent $rel/MD5SUMS | \grep -o "debian-.*$desktop_env*.iso")"
			;;
			* )
				$RTD_GUI --backtitle "$BRANDING" --title "ERROR!" --msgbox "You passed the function ${FUNCNAME[0]} the parameters $@. The 4th parameter should be wither of: kde | gnome | xfce | cinnamon | lxde | lxqt | mate | standard! Not $4 " 10 60
			;;
			esac
		;;
		netinst | net | mini )
			# Find and download mini iso...
		;;
		* )
			$RTD_GUI --backtitle "$BRANDING" --title "ERROR!" --msgbox "You passed the function ${FUNCNAME[0]} the parameters $@. The 2nd parameter should be either of: Live | live | current-live | netinst | net | mini ! not $live_or_not" 10 60
			rtd_oem_pause 1
		;;
		esac
	;;
	*)
		$RTD_GUI --backtitle "$BRANDING" --title "ERROR!" --msgbox "You passed the function ${FUNCNAME[0]} the parameters $@. The 2nd parameter should be either of: Ubuntu | ubuntu Debian | debian! not $distro_flavor" 10 60
		rtd_oem_pause 1
	;;
	esac
}



make_preseed_cfg () {
	# Function to write out a debina preeseed file to a location requested by the first parameter.
	# Other parameters accepted are CONFIG (multiselect de), SRVFUNC (task "Minecraft" "Tasks")
	# some parameters have defaults. 
	# Example: 
	# functoin_name          location        config          function
	# make_preseed_cfg       /path/to/file   ssh-server      Minecraft

	SAVETO=$1
	CONFIG=$2
	SRVFUNC=$3
	: "${SRVFUNC:=Tasks}"
	: "${PRESEED:=preseed.cfg}"
	PRESEED_FILE="$SAVETO/$PRESEED"
	echo "Writing installation instructions for [$CONFIG] in $SAVETO/$PRESEED"
	touch "$1/$PRESEED"

	rtd_oem_preseed_ubuntu_cfg_KS_CFG_Options "$SAVETO"
	rtd_oem_preseed_cfg_Unattended_Install "$SAVETO"
	rtd_oem_preseed_cfg_Network_Configuration "$SAVETO"
	rtd_oem_preseed_cfg_Prevent_Install_On_USB "$SAVETO"
	rtd_oem_cfg_Account_Setup "$SAVETO"
	rtd_oem_preseed_cfg_Localization "$SAVETO"
	rtd_oem_preseed_cfg_EFI "$SAVETO"
	rtd_oem_preseed_cfg_GRUB_Bootloader_Installation "$SAVETO"
	rtd_oem_preseed_cfg_Disk_Layout "$SAVETO"
	rtd_oem_preseed_cfg_Package_Selection "$SAVETO" "$CONFIG"
	rtd_oem_preseed_cfg_Addon_"${SRVFUNC}" "$SAVETO"
}



#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#::::::::::::::                                          ::::::::::::::::::::::
#::::::::::::::    Internal Confgiration Repository      ::::::::::::::::::::::
#::::::::::::::                                          ::::::::::::::::::::::
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#
# Below please find the internally stored and maintained configuration cards.
# When creating Linux installation configurations for use in a virtual envoironment
# or for transferring to physical media to install on a laptop or PC; require
# the creation of preseed and kick start configuration files that "answer" the
# installer's questions. These pieces of configuration files are stored below
# such that they may be applied to the actual configuration file as needed and
# wiht variable instructions, for example: what software to install. Any configuration
# item that needs to be written out to a separate file should be stored in this section.



rtd_oem_preseed_ubuntu_cfg_KS_CFG_Options ()
{
	cat > $1/ks.cfg <<- EOF
		# --------------------------------------------------- #
		# KS.CFG Options
		# --------------------------------------------------- #
		# Simple instruction to tell the Ubuntu installer that
		# this is intended to be an unattended install and to only
		# ask critical questions (wich we will answer in this file)
		# Add options here from these instructions:
		#
		# https://pykickstart.readthedocs.io/en/latest/kickstart-docs.html#chapter-2-kickstart-commands-in-fedora
		#
		# Please note that some options in kickstart are superceeded by preseed.
		#
		lang en_US.UTF-8
		keyboard se
		timezone $(cat /etc/timezone)
		install
		text
		cdrom
		bootloader --location=mbr
		zerombr yes
		clearpart --all --initlabel
		skipx
		reboot

		# --------------------------------------------------- #
	EOF
}



rtd_oem_preseed_cfg_Unattended_Install ()
{
	cat >> $1/$PRESEED <<-'EOF'
		# --------------------------------------------------- #
		# Unattended Installation
		# --------------------------------------------------- #
		# Simple instruction to tell the debian installer that
		# this is intended to be an unattended install and to only
		# ask critical questions (wich we will answer in this file)
		d-i auto-install/enable boolean true
		d-i debconf/priority select critical
		# --------------------------------------------------- #
	EOF
}


rtd_oem_preseed_cfg_Network_Configuration ()
{
	cat >> $1/$PRESEED <<-'EOF'

		# --------------------------------------------------- #
		# Network configuration
		# --------------------------------------------------- #
		# Network setup. This can be a static setup or dhcp.
		d-i netcfg/choose_interface select manual
		d-i netcfg/hostname string RTD-Client
		d-i netcfg/get_hostname string unassigned-hostname
		d-i netcfg/get_domain string unassigned-domain
		d-i hw-detect/load_firmware boolean true

		# We want the preconfiguration file to work on systems both with and
		# without sucessful dhcp configuration
		d-i netcfg/dhcp_failed note
		d-i netcfg/dhcp_options select Configure network manually
		# d-i netcfg/dhcp_timeout string 60

		d-i netcfg/wireless_show_essids select manual
		d-i netcfg/wireless_essid string loader
		d-i netcfg/wireless_essid_again string loader
		d-i netcfg/wireless_security_type select wpa
		d-i netcfg/wireless_wpa string letmein1234

		# --------------------------------------------------- #
	EOF
}


rtd_oem_cfg_Account_Setup ()
{
	cat >> $1/$PRESEED <<-'EOF'
		# --------------------------------------------------- #
		# Account setup (temporary user account)
		# --------------------------------------------------- #
		# Setup an initial user and disable root login by default.
		# root login may be re-enabled later by setting a root password.
		# An encrypted password is set here, and should be changed
		# ASAP after the system is built. Preferebly connect to LDAP/AD
		# in a managed environment.
		d-i passwd/root-login boolean false
		d-i passwd/user-fullname string RTD User
		d-i passwd/username string tangarora
		d-i passwd/user-password seen true
		d-i user-setup/allow-password-weak boolean true
		d-i passwd/user-password-crypted password $6$Rn5/UTzjIs68MX$9gz8vmshGlPqse3VoX8dzSfhWxRVoYv1MB6aGRD8xdvztOf.gD.SxxVWkxYrwwbShB9Q14flquK/apbdQJ65t1
		d-i passwd/auto-login boolean true

		# --------------------------------------------------- #
	EOF
}


rtd_oem_preseed_cfg_Prevent_Install_On_USB ()
{
	cat >> $1/$PRESEED <<-'EOF'
		# --------------------------------------------------- #
		# Do NOT install on the USB stick(!)
		# --------------------------------------------------- #
		#
		# The Debian installer will install on the first disk it finds which can
		# sometimes be the USB stick itself. Work around this by rolling our own auto
		# detect logic which disallows installing on USB devices.
		#
		# d-i partman/early_command string [ "$(ls -A /tmp)" ] && umount -l /media || echo "Empty" ;
		d-i partman/early_command string \
			USBDEV=$(mount | grep hd-media | cut -d" " -f1 | sed "s/\(.*\)./\1/");\
			BOOTDEV=$(list-devices disk | grep -v \$USBDEV | head -1);\
			debconf-set partman-auto/disk $BOOTDEV;\
			debconf-set grub-installer/bootdev $BOOTDEV;

		# --------------------------------------------------- #
	EOF
}


rtd_oem_preseed_cfg_EFI ()
{
	cat >> $1/$PRESEED <<-'EOF'
		# --------------------------------------------------- #
		# EFI
		# --------------------------------------------------- #
		#
		# The EFI (Extensible Firmware Interface) system partition is a partition on a data storage device.
		# UEFI provides backward compatibility with legacy systems by reserving the first block (sector) of
		# the partition for compatibility code, effectively creating a legacy boot sector. On legacy BIOS-based
		# systems, the first sector of a partition is loaded into memory and execution is transferred to this code.
		# Here we tell setup to install EFI boot setup if possible so that both NEW and old systems may be handled
		# and the installed system can be started.
		d-i partman-efi/non_efi_system boolean true
		# --------------------------------------------------- #
	EOF
}



rtd_oem_preseed_cfg_Localization () 
{
	cat >> $1/$PRESEED <<-'EOF'
	
		# --------------------------------------------------- #
		# Localization
		# --------------------------------------------------- #
		# Provide localizaton preferences so that the prefferred
		# language is used for display and formats. Comparable to 
		# the MUI in Microsoft environments.
		d-i debian-installer/locale string en_US.UTF-8
		d-i localechooser/supported-locales multiselect en_US.UTF-8, se_SE.UTF-8
		d-i console-setup/ask_detect boolean false
		# --------------------------------------------------- #
		
		

		# --------------------------------------------------- #
		# Set Keyboard layout
		# --------------------------------------------------- #
		# Set the prefferred keyboard layout. Keyboards will work
		# regardless, but the letters and symbols may not actually
		# be the ones drawn on the keys. Default is us.
		d-i keyboard-configuration/xkb-keymap select se
		d-i keyboard-configuration/layoutcode string se
		d-i debian-installer/keymap select se
		d-i keymap select se
		d-i console-setup/layoutcode string se
		d-i console-setup/ask_detect boolean false

		# --------------------------------------------------- #

		EOF
}



rtd_oem_preseed_cfg_GRUB_Bootloader_Installation ()
{
	cat >> $1/$PRESEED <<-'EOF'
		# --------------------------------------------------- #
		# GRUB bootloader installation
		# --------------------------------------------------- #
		#
		# Tell the grub-installer to install to the MBR even if it also finds some other
		# OS, which is more likely to allow the newly installed Linux OS to boot without issue.
		d-i grub-installer/only_debian boolean true
		d-i grub-installer/with_other_os boolean true
		# --------------------------------------------------- #
	EOF
}



rtd_oem_preseed_cfg_Disk_Layout ()
{
	cat >> $1/$PRESEED <<-'EOF'
		# --------------------------------------------------- #
		#   Disk layout
		# --------------------------------------------------- #
		#
		## Set option to encrypt the hard disk:
		d-i partman-auto/method string crypto
		d-i partman-crypto/passphrase password letmein1234
		d-i partman-crypto/passphrase-again password letmein1234
		d-i partman-auto-crypto/erase_disks boolean false
		d-i partman-lvm/device_remove_lvm boolean true
		d-i partman-lvm/device_remove_lvm_span boolean true
		d-i partman-auto/purge_lvm_from_device boolean true
		d-i partman-lvm/confirm boolean true
		d-i partman-lvm/confirm_nooverwrite boolean true
		d-i partman-auto-lvm/guided_size string max
		d-i partman-auto-lvm/new_vg_name string crypt
		# d-i partman-auto/disk string /dev/sdb
		d-i partman-auto/choose_recipe select root-encrypted
		d-i partman-auto/expert_recipe string                   \
		root-encrypted ::                                       \
				538 538 1075 free                       \
				$primary                                \
				$iflabel{ gpt }                         \
				$reusemethod{ }                         \
				method{ efi } format{ }                 \
			.                                               \
			500 500 500 ext3                                \
				$primary{ } $bootable{ }                \
				method{ format } format{ }              \
				use_filesystem{ } filesystem{ ext4 }    \
				mountpoint{ /boot }                     \
									\
			.                                               \
			2000 2000 2000 linux-swap                       \
				$lvmok{ } lv_name{ swap }               \
				in_vg { crypt }                         \
				$primary{ }                             \
				method{ swap } format{ }                \
			.                                               \
			500 10000 1000000000 ext4                       \
				$lvmok{ } lv_name{ root }               \
				in_vg { crypt }                         \
				$primary{ }                             \
				method{ format } format{ }              \
				use_filesystem{ } filesystem{ ext4 }    \
				mountpoint{ / }                         \
			.                                               \
			2000 2000 2000 ext4                             \
				$primary{ }                             \
				method{ keep }                          \
				use_filesystem{ } filesystem{ ext4 }    \
				label{ rescuedisk }                     \
			.

		d-i partman-md/device_remove_md boolean true
		d-i partman-md/confirm boolean true
		d-i partman-basicfilesystems/no_mount_point boolean false
		d-i partman-partitioning/confirm_write_new_label boolean true
		d-i partman/choose_partition select finish
		d-i partman/confirm boolean true
		d-i partman/confirm_nooverwrite boolean true
		# --------------------------------------------------- #
	EOF
}




rtd_oem_preseed_cfg_Package_Selection ()
{
	cat >> $1/$PRESEED <<-EOF
		# --------------------------------------------------- #
		# Package selection
		# --------------------------------------------------- #
		# Packages may be selected as groups (meta packages) like kde-desktop or
		# as individual packages. Only one "pkgsel/include" string will be used though!
		# remembder to fit all the packages you want on one line.
		# tasksel tasksel/first multiselect standard options:
		# ubuntu-desktop-minimal kubuntu-desktop, ubuntu-gnome-desktop, lubuntu-desktop, ubuntu-mate-desktop
		# desktop,  gnome-desktop, kde-desktop, cinnamon-desktop, mate-desktop,
		# lxde-desktop, web-server, ssh-server, print-server.
		# The "OEM" line below ist to make it simple to replace the line with a
		# relevant chice of debian role using "sed" or similar. 
		tasksel tasksel/first multiselect $2
		d-i pkgsel/include string splash openssh-server virt-what wget spice-vdagent 

		# Valid choices for pkgsel/upgrade are: safe-upgrade full-upgrade none
		d-i pkgsel/upgrade select none
		d-i pkgsel/update-policy select unattended-upgrades

		# By default, the system’s locate database will be updated after the
		# installer has finished installing most packages. This may take a while, so
		# if you don’t want it, you can set this to "false" to turn it off.
		# d-i pkgsel/updatedb boolean false
		# --------------------------------------------------- #
	EOF
}
rtd_oem_preseed_cfg_Addon_Minecraft() {
	cat >> $1/$PRESEED <<-'EOF'
		# --------------------------------------------------- #
		# Addon Tasks
		# --------------------------------------------------- #
		d-i preseed/late_command string \
			in-target mkdir -p /etc/systemd/system/getty@tty1.service.d ; \
			in-target echo "***********  Updating Autologin information... ************ "; \
			in-target echo "[Service]" > /etc/systemd/system/getty@tty1.service.d/override.confv ; \
			in-target echo "ExecStart=" >> /etc/systemd/system/getty@tty1.service.d/override.conf ; \
			in-target echo "ExecStart=-/sbin/agetty --noissue --autologin tangarora "%I" "$TERM"" >> /etc/systemd/system/getty@tty1.service.d/override.conf ; \
			in-target echo "Type=idle" >> /etc/systemd/system/getty@tty1.service.d/override.conf ; \
			in-target echo "**********    Seting up minecraft.server to start automatically   ************* " ; \
			in-target echo "bash /home/tangarora/minecraft.server" >> /home/tangarora/.bashrc ; \
			in-target wget https://github.com/vonschutter/RTD-Minecraft-Server-Manager/raw/master/minecraft-server -O /home/tangarora/minecraft.server && chmod +x /home/tangarora/minecraft.server  ; \
			umount -l /media || echo "Empty"; \
			eject || true; \
			echo "------  initial Setup Complete!  ------"

		# Answer the last question
		d-i debian-installer/splash boolean true

		# Option to try to greacefully eject the installation media:
		d-i cdrom-detect/eject boolean true

		# Shutdown machine
		d-i finish-install/reboot_in_progress note
	
		# --------------------------------------------------- #
	EOF
}

rtd_oem_preseed_cfg_Addon_Tasks ()
{
	cat >> $1/$PRESEED <<-'EOF'
		# --------------------------------------------------- #
		# Addon Tasks
		# --------------------------------------------------- #
		d-i preseed/late_command string \
			mkdir -p /target/opt/rtd/scripts; \
			mkdir -p /target/opt/rtd/log; \
			cp -r /custom /target/opt/rtd/custom; \
			cp /preseed.cfg /target/opt/rtd/log/; \
			in-target wget -O /opt/rtd/scripts/post-install.sh "https://github.com/vonschutter/Blind_Install/raw/master/custom/task.sh" --no-check-certificate ; \
			in-target chmod +x /opt/rtd/scripts/post-install.sh; \
			in-target /opt/rtd/scripts/post-install.sh; \
			umount -l /media || echo "Empty"; \
			eject || true; \
			echo "------  initial Setup Complete!  ------"

		# Answer the last question
		d-i debian-installer/splash boolean true

		# Option to try to greacefully eject the installation media:
		d-i cdrom-detect/eject boolean true

		# Shutdown machine
		d-i finish-install/reboot_in_progress note

		# --------------------------------------------------- #
	EOF
}






#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#::::::::::::::                                          ::::::::::::::::::::::
#::::::::::::::            Tool GUI Functions            ::::::::::::::::::::::
#::::::::::::::                                          ::::::::::::::::::::::
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#
# Functions that control how the the RTD menus are displayed are listed below
# in this section for better manageability. When scripts become rather large
# they become cumbersome to manage, then it is sometimes helpful to sections
# in some logical order.
BRAND="  $BRANDING		Verson:$RTD_Version : on $HOSTNAME"
BRANDING=$BRAND

display_result () {
        $RTD_GUI --backtitle "$BRANDING" --title "$1" \
        --msgbox "$result" $HEIGHT $WIDTH $LIST_HEIGHT
}



display_notice () {
	# Function to display a notice that the ISO creation is complete.
	# And describe what to de next.
	$RTD_GUI --backtitle "$BRANDING" \
	--title "About" \
	--msgbox "
This tool is part of the RTD System Support Tools. The purpose of this tool is to generate an unattended installation ISO file that can be used directly by a virtual machine in KVM, Oracle Virtual Box, or VMware. Alternatively, this Image may be appled to a thumb drive using "dd" or "etcher", or burned to optical media using "K3B" or another favorite CD/DVD burining software.

This script will:
  - Download the latest installation image
  - Patch the installation media with the instructions to auto-install.
  - The instructios will encrypt the hard drive and install, automatically.
  - The default disk encryption password is: "letmein1234"
  - The default system login and admin temporary password is: "letmein"
  - The defaults will be dused if you make no other active choices"  $HEIGHT $WIDTH $LIST_HEIGHT
}



show_notice_on_fist_run () {
	if [ -f ~/.config/rtd-first-run-$RTD_Version ]; then
		echo $RTD_Version has been used already and terms reviewed...
	else
		show_notice_on_fist_run_TEXT="
This looks like the first time you run this vesion of the RTD tools. Please note that these tools are provided as-is and for modification.

The RTD tools run in a separate terminal that you can re connect to if you should get disconnected. This can be done by:
- re-connecting to the server with ssh
- then running command "byobu" if a session is already running on the server"

		$RTD_GUI --backtitle "$BRANDING" --title "DONE" --msgbox "$show_notice_on_fist_run_TEXT" 15 80
		touch ~/.config/rtd-first-run-$RTD_Version
		clear
	fi


}



cleanup_and_finish () {
	# Function to remove all temporary file locations left over from building
	# the new netinstall ISO etc. and clean  up some variables...
	# go back to initial directory
	cd "$CURRENT_DIR" && echo "returned to $CURRENT_DIR" || echo "No directory to return to... never mind."
	# Cleanup folder structure...
	rm -r "$TMP_DOWNLOAD_DIR"
	rm -r "$TMP_DISC_DIR"
	rm -r "$TMP_INITRD_DIR"
	rm -r "$SCRIPT_DIR/custom"

	if [[  "$1" != "nomessage" ]]; then 
		COMPLETION_MESSAGE="	Your ISO image is ready!
		It is placed in the folder: $PUT_ISO_FILE_HERE_WHEN_DONE/

		Next steps:
		- Burn the ISO to a USB (ex: using MULTIBOOT from Pendrive Linux)
		- If you are using Virtual Machines select the ISO as install media
		- Boot from the media created: allow it to install the system
		- login as the temporary user (temporary password: letmein)
		- Adjust passwords for the encrypted volume and login... "

		$RTD_GUI --backtitle "RTD OEM System Builder" --title "DONE" --msgbox "$COMPLETION_MESSAGE" 15 80
	else 
		#silent
		echo "Cleanup..."
	fi

	# Print COMPLETION_MESSAGE
	unset BIN_7Z
	unset BIN_XORRISO
	unset BIN_CPIO
	unset ISOHDPFX_BIN
	unset VOLUME_TITLE
	unset TARGET_ISO_FILE_NAME
	unset SOURCE_ISO_URL
	unset SSH_PUBLIC_KEY_FILE
	unset PRESEED_TEMPLATE
	unset CONFIG
	clear
	return
}




rtd_setup_choices_cli_workstation () {
	# Function to display legacy installation options. This will install software that is usefull
	# on a really old system, or a remote system only accessible via SSH. This may be a good
	# usecase if you happen to be in an opressed geographic locaiton where your only option is
	# to ssh to a remote server and access email and web that way. Perfomance in these cases
	# may be very poor over the internet (as for example with the great firewall of China). In
	# Such a case it would be usefull to have the good old CLI software! :)
	# List Options to be available for choice in the RTD System Configurator...
	cmd=($RTD_GUI --backtitle "$BRANDING" --title "Terminal Software add on Options Menu" --separate-output --checklist "You can be productive in the cli environment. Please Select Software titles below that you want to add to this system:" $HEIGHT $WIDTH $LIST_HEIGHT )
	options=(1 "Base RTD OEM Software (basic admin tools usually needed)" on
		 2 "Alpine email client" off
		 3 "Vim text editor" on
		 4 "Finch multi protocol chat" off
		 5 "Word Grinder word precessor" off
		 6 "Spreadsheet Calculator" off
		 7 "TPP Presentation Program" off
		 8 "Midnight Commander file manager (Norton Commander)" on
		 9 "Cmus Music Player" off
		 10 "Byobu Terminal Window Manger" off
		 11 "W3M web Browser" off
		 12 "LYNX Web Browser (Browse the web directly in the terminal)" off
		 13 "Mega.nz command line tools (Mega-CMD)" off
		 14 "Rtorrent torrent download software" off
		 15 "Install the OpenVpn client Software" off
		 16 "Games: Freesweep mine sweep game" off
		 17 "Games: Bastet Tetris Game" off
		)

		choices=$("${cmd[@]}" "${options[@]}" 2>&1 >/dev/tty)
		clear
		for choice in $choices
		do
			case $choice in
			1) for i in wine-stable ffmpeg netstat nmcli htop powertop iftop monit nethogs bmon darkstat ss mtr glances nmap iostat multitail ncdu multitail ; do InstallSoftwareFromRepo $i ; done ;;
			2) InstallSoftwareFromRepo alpine ;;
			3) InstallSoftwareFromRepo vim ;;
			4) InstallSoftwareFromRepo finch ;;
			5) InstallSoftwareFromRepo wordgrinder ;;
			6) InstallSoftwareFromRepo sc ;;
			7) InstallSoftwareFromRepo tpp ;;
			8) InstallSoftwareFromRepo mc ;;
			9) InstallSoftwareFromRepo cmus ;;
			10) InstallSoftwareFromRepo byobu ;;
			11) InstallSoftwareFromRepo w3m ;;
			12) InstallSoftwareFromRepo lynx ;;
			13) dl https://mega.nz/linux/MEGAsync/xUbuntu_19.04/amd64/ megacmd-*.deb ;;
			14) InstallSoftwareFromRepo rtorrent ;;
			15) InstallSoftwareFromRepo openvpn ;;
			16) InstallSoftwareFromRepo freesweep ;;
			17) InstallSoftwareFromRepo bastet ;;
			esac
		done
}



show_make_media_gui_server ()
{
	while true; do
		exec 3>&1
		selection=$($RTD_GUI \
		--backtitle "$BRANDING" --title "Create Automatic OS Install Media"  --menu "Please select which automatic operating system installation media to create.  (to Burn to CD, or trafer to a USB, or use with a VM):" $HEIGHT $WIDTH $LIST_HEIGHT  \
		"1" "Automatic Install ISO for Ubuntu Server" \
		"2" "Automatic Install ISO for Ubuntu Graphical Server" \
		"3" "Automatic Install ISO for Debian Graphical Server" \
		"4" "Automatic Install ISO for Debian Minimal Server" \
		"5" "Automatic Install ISO for Minecraft Server (Latest)"
		2>&1 1>&3)
		exit_status=$?
		exec 3>&-

		case $exit_status in
			$DIALOG_CANCEL) return	;;
			$DIALOG_ESC) exit 1 ;;
		esac

		case $selection in
		0 )
			echo "Program terminated by user..."
		;;
		1 )
			rtd_oem_ubuntu_auto_install_iso_builder openssh-server server
			cleanup_and_finish
		;;
		2 )
			rtd_oem_ubuntu_auto_install_iso_builder xubuntu-core server
			cleanup_and_finish
		;;
		3 )
			prepare_environment_for_iso_creation
			download_and_manipulate_iso_debian debian lxde-desktop server
			create_iso_image_debian
			cleanup_and_finish
		;;
		4 )
			prepare_environment_for_iso_creation
			download_and_manipulate_iso_debian debian openssh-server server
			create_iso_image_debian
			cleanup_and_finish
		;;
		5 )
			prepare_environment_for_iso_creation
			download_and_manipulate_iso_debian debian openssh-server MinecraftTasks
			create_iso_image_debian
			cleanup_and_finish	
                ;;
		esac
	done
}



show_make_media_gui_desktop () {
	# List Options to be available for choice in the RTD System Configurator...
	while true; do
		exec 3>&1
		selection=$($RTD_GUI \
		--backtitle "$BRANDING" --title "Create Automatic OS Install Media"  --menu "Please select which automatic operating system installation media to create.  (to Burn to CD, or trafer to a USB, or use with a VM):" $HEIGHT $WIDTH $LIST_HEIGHT  \
		"1" "Automatic Install ISO/VDI for Ubuntu Standard Desktop (more MAC like)" \
		"2" "Automatic Install ISO/VDI for Ubuntu with Plasma Desktop (more Windows like)" \
		"3" "Automatic Install ISO/VDI for Ubuntu Gnome (without Ubuntu customization)" \
                "4" "Automatic Install ISO/VDI for Ubuntu Minimal Standard desktop" \
		"5" "Automatic Install ISO/VDI for Debian Default Desktop" \
		"6" "Automatic Install ISO/VDI for Debian Light Weight Desktop" \
		"7" "Automatic Install ISO/VDI for Debian Plasma Desktop" \
		2>&1 1>&3)
		exit_status=$?
		exec 3>&-

		case $exit_status in
			$DIALOG_CANCEL) return	;;
			$DIALOG_ESC) exit 1 ;;
		esac

		case $selection in
		0 )
			echo "Program terminated by user..."
		;;
		1 )
			rtd_oem_ubuntu_auto_install_iso_builder ubuntu-desktop desktop
			cleanup_and_finish
		;;
		2 )
			rtd_oem_ubuntu_auto_install_iso_builder kubuntu-desktop server
			cleanup_and_finish
		;;
		3 )
			rtd_oem_ubuntu_auto_install_iso_builder ubuntu-gnome-desktop server
			cleanup_and_finish
		;;
                4 )
			rtd_oem_ubuntu_auto_install_iso_builder ubuntu-desktop-minimal desktop
			cleanup_and_finish
		;;
		5 )
			prepare_environment_for_iso_creation
			download_and_manipulate_iso_debian debian-desktop desktop
			create_iso_image_debian
			cleanup_and_finish
		;;
		6 )
			prepare_environment_for_iso_creation
			download_and_manipulate_iso_debian debian cinnamon-desktop
			create_iso_image_debian
			cleanup_and_finish
		;;
		7 )
			prepare_environment_for_iso_creation
			download_and_manipulate_iso_debian debian kde-desktop
			create_iso_image_debian
			cleanup_and_finish
		;;
		esac
	done
}



show_manage_vm_gui () {
	# List Options to be available for choice in the RTD System Configurator...
	while true; do
		exec 3>&1
		selection=$($RTD_GUI \
		--backtitle "$BRANDING" \
		--title "VM Managment Menu"  \
		--menu "Please select what you would like to do below:"  $HEIGHT $WIDTH $LIST_HEIGHT \
		"1" "List all virtual machines on this system" \
		"2" "Backup all running virtual machines on this server" \
		"3" "Monitor VM's on this system "\
		"4" "Make boot media for auto installing on a physical system" \
		"5" "Deploy a VM on this server" \
		2>&1 1>&3 )
		exit_status=$?
		exec 3>&-

		case $exit_status in
			$DIALOG_CANCEL) return ;;
			$DIALOG_ESC) exit 1 ;;
		esac

		PREVIOUS_MENU=$PREVIOUS_MENU

		case $selection in
		0 )
			echo "Program terminated by user..."
		;;
		1 )
			if hash virsh ; then
				result=$(virsh list --all )
				display_result "Virtual Machinces on this system:"
			else
				echo KVM Virtualization is not installed on this machine.
			fi
		;;
		2 ) 
			backup_running_vm
		;;
		3)
			echo "VM Status on This HOST: Press [Q] to quit."
			check_dependencies virt-top
			virt-top
		;;
		4 )
			while true; do
				exec 3>&1
				subselection1=$($RTD_GUI --backtitle "$BRANDING" --title "Create Automatic OS Install Media" --menu "Please select choose if you need to make media for a server or a desktop. You will be aksed if you you want to transfer the media to a DC/DVD/USB Stick or deploy directly as a VM"  $HEIGHT $WIDTH $LIST_HEIGHT \
				"1" "Make media to build a server (ISO or USB Disk)" \
				"2" "Make media to build a Desktop environment (ISO or USB Disk)" \
				2>&1 1>&3)
				exit_status=$?
				exec 3>&-

				case $exit_status in
					$DIALOG_CANCEL) return	;;
					$DIALOG_ESC) exit 1 ;;
				esac

				case $subselection1 in
					0 ) echo "Program terminated."
					;;
					1 ) show_make_media_gui_server
					;;
					2 ) show_make_media_gui_desktop
					;;
				esac
			done
		;;
		5 )
			while true; do
				exec 3>&1
				subselection2=$($RTD_GUI --backtitle "$BRANDING" --title "Make Virtual Machine" --menu "    "  $HEIGHT $WIDTH $LIST_HEIGHT \
				"1" "Make a server VM (Minimal single purpose system)" \
				"2" "Make a VM with a desktop environment (VDI)" \
				2>&1 1>&3)
				exit_status=$?
				exec 3>&-

				case $exit_status in
					$DIALOG_CANCEL) return	;;
					$DIALOG_ESC) exit 1 ;;
				esac

				case $subselection2 in
					0) echo "Program terminated."
					;;
					1) show_deploy_server_VM_now_menu
					;;
					2) show_deploy_VDI_VM_now_menu
					;;
				esac
			done
		;;
		esac
	done
}




show_deploy_server_VM_now_menu ()
{

		while true; do
		exec 3>&1
		selection=$($RTD_GUI \
		--backtitle "$BRANDING" --title "Create Automatic OS Install Media"  --menu "Please select which type of VM to create:" $HEIGHT $WIDTH $LIST_HEIGHT \
		"1" "Ubuntu Server" \
		"2" "Ubuntu Graphical Server" \
		"3" "Debian Graphical Server" \
		"4" "Debian Minimal Server" \
		2>&1 1>&3)
		exit_status=$?
		exec 3>&-

		case $exit_status in
			$DIALOG_CANCEL) return	;;
			$DIALOG_ESC) exit 1 ;;
		esac

		PREVIOUS_MENU=${FUNCNAME[0]}
		case $selection in
		0 )
			echo "Program terminated by user..."
		;;
		1 )
			rtd_oem_ubuntu_auto_install_iso_builder ssh-server server
			make_kvm_virtual_machine_now_from_iso ubuntu19.10
			cleanup_and_finish
		;;
		2 )
			rtd_oem_ubuntu_auto_install_iso_builder xubuntu-core server
			make_kvm_virtual_machine_now_from_iso ubuntu19.10
			cleanup_and_finish
		;;
		3 )
			prepare_environment_for_iso_creation
			download_and_manipulate_iso_debian debian lxde-desktop
			create_iso_image_debian
			make_kvm_virtual_machine_now_from_iso debian10
			cleanup_and_finish
		;;
		4 )
			prepare_environment_for_iso_creation
			download_and_manipulate_iso_debian debian ssh-server
			create_iso_image_debian
			make_kvm_virtual_machine_now_from_iso debian10
			cleanup_and_finish
		;;
		esac

	done
}



show_deploy_VDI_VM_now_menu ()
{
	while true; do
		exec 3>&1
		selection=$($RTD_GUI --backtitle "$BRANDING" --title "Deploy Virtual Desktop (VDI)"  --menu "Please select which VDI to create on this server:" $HEIGHT $WIDTH $LIST_HEIGHT \
		"1" "Ubuntu Standard Desktop (more MAC like)" \
		"2" "Ubuntu with Plasma Desktop (more Windows like)" \
		"3" "Ubuntu Gnome (without Ubuntu customization)" \
                "4" "Ubuntu Minimal Standard desktop" \
		"5" "Debian Default Desktop" \
		"6" "Debian Cinnamon Desktop" \
		"7" "Debian Plasma Desktop" \
		"8" "Debian Light Weight Desktop (LXDE)" \
		2>&1 1>&3)
		exit_status=$?
		exec 3>&-

		case $exit_status in
			$DIALOG_CANCEL) return	;;
			$DIALOG_ESC) exit 1 ;;
		esac
		
		case $selection in
		0 )
			clear
			echo "Program terminated by user..."
		;;
		1 )
			rtd_oem_ubuntu_auto_install_iso_builder ubuntu-desktop desktop
			make_kvm_virtual_machine_now_from_iso ubuntu20.04
			cleanup_and_finish
		;;
		2 )
			rtd_oem_ubuntu_auto_install_iso_builder kubuntu-desktop server
			make_kvm_virtual_machine_now_from_iso ubuntu20.04
			cleanup_and_finish
		;;
		3 )
			rtd_oem_ubuntu_auto_install_iso_builder ubuntu-gnome-desktop server
			make_kvm_virtual_machine_now_from_iso ubuntu20.04
			cleanup_and_finish
		;;
                4 )
			rtd_oem_ubuntu_auto_install_iso_builder ubuntu-desktop-minimal desktop
			make_kvm_virtual_machine_now_from_iso ubuntu20.04
			cleanup_and_finish
		;;
		5 )	
			clear
			echo "***   Deploying a Debian VDI with Gnome Desktop from debian.org"
			make_preseed_cfg $( mktemp -d ) gnome-desktop
			make_kvm_virtual_machine_now_from_debian_org debian10
			cleanup_and_finish nomessage
		;;
		6 )
			clear
			echo "***   Deploying a Debian VDI with Cinnamon Desktop from debian.org"
			make_preseed_cfg $( mktemp -d ) cinnamon-desktop
			make_kvm_virtual_machine_now_from_debian_org debian10
			cleanup_and_finish nomessage
		;;
		7 )
			clear
			echo "***   Deploying a Debian VDI with KDE Desktop from debian.org"
			make_preseed_cfg $( mktemp -d ) kde-desktop
			make_kvm_virtual_machine_now_from_debian_org debian10
			cleanup_and_finish nomessage
		;;
		8 )
			clear
			make_preseed_cfg $( mktemp -d ) lxde-desktop
			echo "***   Deploying a Debian VDI with $CONFIG from debian.org"
			make_kvm_virtual_machine_now_from_debian_org debian10
			cleanup_and_finish nomessage
		;;
		esac

	done
}




show_view_informaion_about_this_system () {
	while true; do
		exec 3>&1
		selection=$($RTD_GUI --backtitle "$BRANDING" --title "System Information Menu" --menu "" $HEIGHT $WIDTH $LIST_HEIGHT \
		"1" "Show system summary" \
		"2" "Show storage device space utilization" \
		"3" "Show users HOME folder storage use" \
		"4" "Show system temperature information" \
		"5" "Show detailed system CPU information" \
		"6" "Show systems physical location (city, county etc.)" \
		2>&1 1>&3)
		exit_status=$?
		exec 3>&-

		case $exit_status in
			$DIALOG_CANCEL) return	;;
			$DIALOG_ESC) exit 1 ;;
		esac

		case $selection in
		0 )
		clear
		echo "Program terminated by user..."
		;;
		1 )
			clear
			check_dependencies neofetch
			clear
			neofetch --memory_display barinfo
			ip -br addr
			read -p "Press [Enter] key to return to the main menu: "
		;;
		2 )
			clear
			echo "Please wait while I calculate disk space... "
			result=$(df -h -x squashfs -x tmpfs)
			$RTD_GUI --backtitle "$BRANDING" --title "System Sorage Space" --msgbox --scrolltext "$result" 20 100
		;;
		3 )
			clear
			echo "Please wait while I calculate disk space... "
			result=$(du -sh /home/* 2> /dev/null)
			display_result "Home Space Utilization (All Users)"
		;;
		4 )
			check_dependencies lm-sensors
			sudo /etc/init.d/kmod start
			check_dependencies hddtemp
			sudo sensors-detect --auto
			clear
			result=$(sudo hddtemp /dev/sda; sensors )
			display_result "System Temperature Information"
		;;
		5 )
			clear
			result=$(lscpu)
			display_result "System CPU Information"
		;;
		6 )
			clear
			check_dependencies curl &>/dev/null
			check_dependencies dnsutils &>/dev/null
			result=$(curl ipinfo.io/$(dig +short myip.opendns.com @resolver1.opendns.com))
			display_result "This systems location on the Internet"
		;;
		esac
	done
}



show_manage_software_gui () {
	# List Options to be available for choice in the RTD System Configurator...
	while true; do
		exec 3>&1
		selection=$($RTD_GUI \
		--backtitle "$BRANDING" --title "Software Managment Menu"  --menu "" $HEIGHT $WIDTH $LIST_HEIGHT \
		"1" "Update all software on this system" \
		"2" "Show what Personal Package Archives (PPA's) are defined on this system" \
		"3" "Remove all Personal Package Archives (PPA's) NOT in use on this system" \
		"4" "Attempt a full release upgrade " \
		"5" "Install Non-GUI productivity tools for a useful terminal based workstation" \
		2>&1 1>&3)
		exit_status=$?
		exec 3>&-

		case $exit_status in
			$DIALOG_CANCEL) return	;;
			$DIALOG_ESC) exit 1 ;;
		esac

		case $selection in
		0 )
			clear
			echo "Program terminated by user..."
		;;
		1 )
			clear
			rtd_update_system
			read -p "Press [Enter] key to return to the main menu: "
		;;
		2 )
			clear
			rtd_ppa_checker
			read -p "Press [Enter] key to let me know when you are done reading."
		;;
		3 )
			clear
			rtd_ppa_checker --delete
			read -p "Press [Enter] key to let me know when you are done reading."
		;;
		4 )
			clear
			if hash do-release-upgrade 2>/dev/null ; then
				do-release-upgrade
				read -p "Press [Enter] key to let me know when you are done reading."
			else
				read -p "This function requires the program "do-release-upgrade" (Ubuntu) on your system. Press [Enter] key to return to menu."
			fi
		;;
		5 )
			rtd_setup_choices_cli_workstation
		;;
		esac
	done
}



show_main_menu () {
	while true; do
		exec 3>&1
		# Dialog Display Menu Items...
			selection=$( $RTD_GUI --backtitle "$BRANDING" --title "RTD Tool Main Menu" --menu "" $HEIGHT $WIDTH $LIST_HEIGHT \
				"1" "View information about this system" \
				"2" "Manage Software on this system" \
				"3" "Manage Virtual Machines (KVM) on this system" \
				"4" "Manage encryption phrases and passwords" \
				"5" "Shortcut: Make an automatic install ISO image (for VM's and CD burning)" \
				"6" "Shortcut: Update this system now"\
				2>&1 1>&3)
			exit_status=$?
			exec 3>&-

		# Cases for how program exited...
		case $exit_status in
			$DIALOG_CANCEL)
				clear
				echo "Program terminated."
				exit
			;;
			$DIALOG_ESC)
				clear
				echo "Program aborted." >&2
				exit 1
			;;
		esac
		PREVIOUS_MENU=${FUNCNAME[0]}
		# What to do depending on selection...
		case $selection in
			0 )
				clear
				echo "Program terminated."
			;;
			1 )	show_view_informaion_about_this_system
			;;
			2 )	show_manage_software_gui
			;;
			3 )	show_manage_vm_gui
			;;
			4 )	show_manage_crypt_sec
			;;
			5 )
			while true; do
				exec 3>&1
				subselection1=$($RTD_GUI --backtitle "$BRANDING" --title "Create Automatic OS Install Media" --menu "Please select choose if you need to make media for a server or a desktop. You will be aksed if you you want to transfer the media to a DC/DVD/USB Stick or deploy directly as a VM"  $HEIGHT $WIDTH $LIST_HEIGHT \
				"1" "Make media to build a server (ISO or USB Disk)" \
				"2" "Make media to build a Desktop environment (ISO or USB Disk)" \
				2>&1 1>&3)
				exit_status=$?
				exec 3>&-

				case $exit_status in
				$DIALOG_CANCEL) return
				;;
				$DIALOG_ESC) exit 1
				;;
				esac
				PREVIOUS_MENU=show_main_menu
				case $subselection1 in
					0 ) echo "Program terminated."
					;;
					1 ) show_make_media_gui_server
					;;
					2 ) show_make_media_gui_desktop
					;;
				esac
			done
			;;
			6 )	rtd_update_system
			;;
		esac
	done
}




show_manage_crypt_sec () {
	while true; do
		exec 3>&1
		# Dialog Display Menu Items...
			selection=$($RTD_GUI \
				--backtitle "$BRANDING" \
				--title "Manage encryption phrases and passwords" \
				--menu "" $HEIGHT $WIDTH $LIST_HEIGHT \
				"1" "Check if a password is stolen" \
				"2" "Change systems disk encrytion pass phrase" \
				"3" "Change "$SUDO_USER" password" \
				2>&1 1>&3)
			exit_status=$?
			exec 3>&-

		# Cases for how program exited...
		case $exit_status in
			$DIALOG_CANCEL)
				return 
			;;
			$DIALOG_ESC)
				clear
				echo "Program aborted." >&2
				exit 1
			;;
		esac
		PREVIOUS_MENU=${FUNCNAME[0]}
		# What to do depending on selection...
		case $selection in
			0 )
				clear
				echo "Program terminated."
			;;
			1 )
				check_if_password_p0wned
			;;
			2 )
				change_disk_pass
			;;
			3 )
				passwd $SUDO_USER
			;;
		esac
	done
}




#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#::::::::::::::                                          ::::::::::::::::::::::
#::::::::::::::          Script templates                ::::::::::::::::::::::
#::::::::::::::                                          ::::::::::::::::::::::
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
# Useful code sniplet templates. Copy and paste these and the edit them
# as necessary to extend the functoinality of this tool.
#




menu_template () {
	while true; do
		exec 3>&1
		# Dialog Display Menu Items...
			selection=$($RTD_GUI \
				--backtitle "$BRANDING" \
				--title "Menu Title" \
				--menu "Please tell me what I can do for you:" $HEIGHT $WIDTH $LIST_HEIGHT \
				"1" "Description" \
				"2" "Description" \
				"3" "Description" \
				2>&1 1>&3)
			exit_status=$?
			exec 3>&-

		# Cases for how program exited...
		case $exit_status in
			$DIALOG_CANCEL)
				clear
				echo "Program terminated."
				exit
			;;
			$DIALOG_ESC)
				clear
				echo "Program aborted." >&2
				exit 1
			;;
		esac

		# What to do depending on selection...
		case $selection in
			0 )
				clear
				echo "Program terminated."
			;;
			1 )
				# code
			;;
			2 )
				# code
			;;
			3 )
				# code
			;;
		esac
	done
}











#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#::::::::::::::                                          ::::::::::::::::::::::
#::::::::::::::          Script Main Init                ::::::::::::::::::::::
#::::::::::::::                                          ::::::::::::::::::::::
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#
# Below is the logic for starting this script. As this script pretty much exclusively uses
# functions and function calls for everything it is simple to control the flow of execution here.
# We must ensure that the script is run at the proper privileges and in a
# re-attachable session. This means that this script will not allow itself to be run in
# a root terminal or using the sudo command. The reason for this is that, in order to start in
# a detachable terminal session "byobu", it may not be launched by root. The script will
# need to be run as a normal administrative user with access to "sudo" a.k.a. a member of the
# "sudoers" security group. This helps adhere to the best practice of NOT using a root interactive
# terminal.

if [[ -z "${BASH_VERSINFO}" ]]; then
	echo "ERROR: You must execute this script in a BASH Shell" >&2
	exit 255
fi

if [[ "$RTD_GUI" == "dialog" ]]; then
	if [[ -f ~/.dialogrc ]]; then
		mv ~/.dialogrc ~/.dialogrc.rtd-bak
		echo "screen_color = ($DIALOG_COLORS)" > ~/.dialogrc
		echo "use_shadow = ON" >> ~/.dialogrc
	else
		echo "screen_color = ($DIALOG_COLORS)" > ~/.dialogrc
	fi
fi


if [[ "$TERM" == screen* ]]; then
	ensure_admin "$@"
	show_notice_on_fist_run
	check_dependencies $RTD_GUI
	show_main_menu

else
	if hash byobu 2>/dev/null; then
		byobu new-session -s "RTD Simple Server Support Tools" "$0 $@"
		#clear
	else
		check_dependencies byobu && echo -e $RED "A critical component needed for this script to work properly was attempted to be added... Attempting to run the script again!" $ENDCOLOR
		su -c "$0 $@" $SUDO_USER
		clear
	fi
fi

if [[ "$RTD_GUI" == "dialog" ]]; then
	if [[ -f ~/.dialogrc.rtd-bak ]]; then
		rm  ~/.dialogrc && mv ~/.dialogrc.rtd-bak ~/.dialogrc
	fi
fi
